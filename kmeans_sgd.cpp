#include "kmeans_sgd.h"
#include "timer.h"
#include <iostream>
#include <iomanip>
using std::clog; using std::endl; using std::flush;

void kMeansSGD::solve ( void ) {
   int size; MPI_Comm_size ( MPI_COMM_WORLD, &size );
   int rank; MPI_Comm_rank ( MPI_COMM_WORLD, &rank );

   // Parallelization: to improve the algorithm, we draw entries in batches. Each
   // process draws a portion of the batch and performs the algorithm
   // Since we don't want two processes to draw the same entry (waste of time and/or
   // possible conflicts) we have the random indexes generated by rank 0 in a
   // unique way, and then sent to the others

   // Size of each batch is in the member batchSize

   std::default_random_engine eng ( 1 );
   std::uniform_int_distribution<unsigned int> distro ( 0, dataset.size() - 1 );

   iter = 0;

   // Randomize initial assignments
   randomize();
   computeCentroids();

   int changes = stoppingCriterion.minLabelChanges + 1;
   real centroidDispl = stoppingCriterion.minCentroidDisplacement + 1;
   std::vector<point> oldCentroids;

   // Counts for how many subsequent iterations the stopping criteria are met; the
   // algorithm stops when it reaches a fixed number (see below)
   // This helps checking that actual convergence takes place
   int stopIters = 0;

   multiTimer tm ( 5 );

   while ( stopIters < 10 ) {
      if ( (stoppingCriterion.maxIter <= 0 || iter < stoppingCriterion.maxIter)
        && (stoppingCriterion.minLabelChanges <= 0 || changes >= stoppingCriterion.minLabelChanges)
        && (stoppingCriterion.minCentroidDisplacement <= 0 || centroidDispl >= stoppingCriterion.minCentroidDisplacement) ) stopIters = 0;
      else stopIters++;

      tm.start ( 0 );
      if ( rank == 0 ) clog << std::setw(8) << iter << " " << flush;

      oldCentroids = centroids;
      changes = 0;

      // Pick random entries in the dataset
      std::vector<int> indices ( batchSize, -1 );
      std::vector<int> oldLabels ( batchSize, -5 );

      indices[0] = distro(eng);
      oldLabels[0] = dataset[indices[0]].getLabel();
      for ( int i = 1; i < batchSize; ++i ) {
         indices[i] = distro(eng);
         oldLabels[i] = dataset[indices[i]].getLabel();
      }

      for ( int i = rank; i < batchSize; i += size ) {
         unsigned int idx = indices[i];

         tm.start(4);
         // Find the nearest centroid
         int nearestLabel = 0;
         real nearestDist = dist2 ( dataset[idx], centroids[0] );

         for ( unsigned int kk = 1; kk < k; ++kk ) {
            real d = dist2 ( dataset[idx], centroids[kk] );
            if ( d < nearestDist ) {
               nearestDist = d;
               nearestLabel = kk;
            }
         }
         tm.stop(4);

         // Set the label of the picked point
         if ( nearestLabel != dataset[idx].getLabel() ) {
            dataset[idx].setLabel(nearestLabel);
         }
      }

      tm.stop ( 0 );
      if ( rank == 0 ) clog << std::setw(8) << tm.getTime(0) << " " << flush;


      tm.start ( 1 );
      char label = -1;
      int oldLabel = -1;

      // Processes communicate the changes
      for ( int i = 0; i < batchSize; ++i ) {
         tm.start ( 2 );
         label = dataset[indices[i]].getLabel();
         MPI_Bcast ( &label, 1, MPI_CHAR, i % size, MPI_COMM_WORLD );
         tm.stop ( 2 );

         tm.start ( 3 );
         if ( rank != i % size ) dataset[indices[i]].setLabel ( label );

         oldLabel = oldLabels[i];

         if ( oldLabel != label ) {
            counts[oldLabel] -= 1;
            counts[label]  += 1;

            for ( unsigned int nn = 0; nn < n; ++nn ) {
               centroids[label][nn] += ( dataset[indices[i]][nn] - centroids[label][nn] ) / counts[label];
               centroids[oldLabel][nn] += ( centroids[oldLabel][nn] - dataset[indices[i]][nn] ) / counts[oldLabel];
            }

            changes++;
         }
         tm.stop(3);
      }
      tm.stop( 1 );
      if ( rank == 0 ) clog << std::setw(8) << tm.getTime(1) << " " << std::setw(8) << changes << endl;

      // Compute the max displacement of the centroids
      if ( stoppingCriterion.minCentroidDisplacement > 0 ) {
         centroidDispl = 0;
         for ( unsigned kk = 0; kk < k; ++kk ) {
            real displ = dist2 ( oldCentroids[kk], centroids[kk] );
            if ( displ > centroidDispl ) centroidDispl = displ;
         }
         centroidDispl = sqrt(centroidDispl);
      }

      ++iter;
   }

   if ( rank == 0 ) {
      clog << "-----------------------------------------" << endl;
      clog << std::setw(8) << iter << " " << tm.cumulatesToString() << endl;
      clog << "-----------------------------------------" << endl;
   }
}
