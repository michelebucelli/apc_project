#include "kmeans_sgd.h"
#include <ctime>
#include <iostream>
using std::clog; using std::endl;

void kMeansSGD::solve ( void ) {
   int size; MPI_Comm_size ( MPI_COMM_WORLD, &size );
   int rank; MPI_Comm_rank ( MPI_COMM_WORLD, &rank );

   // Parallelization: to improve the algorithm, we draw entries in batches. Each
   // process draws a portion of the batch and performs the algorithm
   // Since we don't want two processes to draw the same entry (waste of time and/or
   // possible conflicts) we have the random indexes generated by rank 0 in a
   // unique way, and then sent to the others

   // Size of each batch is in the member batchSize

   std::default_random_engine eng(std::time(NULL));
   std::uniform_int_distribution<unsigned int> distro ( 0, dataset.size() - 1 );

   iter = 0;

   // Count of elements in each class
   std::vector<unsigned int> counts ( k, 0 );

   // Randomize initial assignments
   randomize();
   computeCentroids();

   // Compute initial counts
   for ( int i = rank; i < dataset.size(); i += size )
      counts [ dataset[i].getLabel() ]++;
   MPI_Allreduce ( MPI_IN_PLACE, counts.data(), k, MPI_UNSIGNED, MPI_SUM, MPI_COMM_WORLD );

   unsigned changes = stoppingCriterion.minLabelChanges + 1;
   real centroidDispl = stoppingCriterion.minCentroidDisplacement + 1;
   std::vector<point> oldCentroids;

   while ( (stoppingCriterion.maxIter <= 0 || iter < stoppingCriterion.maxIter)
        && (stoppingCriterion.minLabelChanges <= 0 || changes >= stoppingCriterion.minLabelChanges)
        && (stoppingCriterion.minCentroidDisplacement <= 0 || centroidDispl >= stoppingCriterion.minCentroidDisplacement) ) {

      oldCentroids = centroids;
      changes = 0;

      // Pick random entries in the dataset
      std::vector<int> indices ( batchSize, -1 );
      if ( rank == 0 ) {
         indices[0] = distro(eng);
         for ( unsigned int i = 1; i < batchSize; ++i ) {
            do indices[i] = distro(eng);
            while ( find(indices.begin(), indices.begin() + i, indices[i]) != indices.begin() + i );
         }
      }

      MPI_Bcast ( indices.data(), batchSize, MPI_INT, 0, MPI_COMM_WORLD );

      for ( unsigned int i = rank; i < batchSize; i += size ) {
         unsigned int idx = indices[i];

         // Find the nearest centroid
         int nearestLabel = 0;
         real nearestDist = dist2 ( dataset[idx], centroids[0] );

         for ( unsigned int kk = 1; kk < k; ++kk ) {
            real d = dist2 ( dataset[idx], centroids[kk] );
            if ( d < nearestDist ) {
               nearestDist = d;
               nearestLabel = kk;
            }
         }

         if ( nearestLabel != dataset[idx].getLabel() ) {
            int oldLab = dataset[idx].getLabel();
            
            // Update counts and centroids
            counts[nearestLabel] += 1;
            counts[oldLab] -= 1;

            centroids[nearestLabel] += (dataset[idx] - centroids[nearestLabel]) / counts[nearestLabel];
            centroids[oldLab] += (centroids[oldLab] - dataset[idx]) / counts[oldLab];

            // Set the label of the picked point
            dataset[idx].setLabel(nearestLabel);

            changes++;
         }
      }

      // Processes communicate the changes
      for ( int i = 0; i < batchSize; ++i ) {
         if ( i % size == rank ) {
            int lab = dataset[indices[i]].getLabel();
            for ( int j = 0; j < size; ++j )
               if ( j != rank ) MPI_Send ( &lab, 1, MPI_INT, j, 0, MPI_COMM_WORLD );
         }

         else {
            int lab = 0;
            MPI_Recv ( &lab, 1, MPI_INT, i % size, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE );
            dataset[indices[i]].setLabel ( lab );
         }
      }

      // Rank 0 updates centroids, then sends them to the others
      if ( rank == 0 ) {
         for ( unsigned int i = 0; i < batchSize; ++i ) {
            int label = dataset[indices[i]].getLabel();
            counts[label] += 1;

            point diff = ( dataset[indices[i]] - centroids[label] ) / counts[label];
            centroids[label] += diff;
         }

         // Send to everybody new centroids
         for ( unsigned int kk = 0; kk < k; ++kk )
            for ( int j = 1; j < size; ++j )
               mpi_point_send ( j, centroids[kk] );
      }

      // Other ranks: receive centroids from rank 0
      else {
         for ( unsigned int kk = 0; kk < k; ++kk )
            centroids[kk] = mpi_point_recv ( 0, n );
      }

      // Communicate counts
      MPI_Bcast ( counts.data(), k, MPI_UNSIGNED, 0, MPI_COMM_WORLD );

      // Collect total label changes
      MPI_Allreduce ( MPI_IN_PLACE, &changes, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD );

      // Compute the max displacement of the centroids
      centroidDispl = 0;
      for ( unsigned kk = rank; kk < k; kk += size ) {
         real displ = dist2 ( oldCentroids[kk], centroids[kk] );
         if ( displ > centroidDispl ) centroidDispl = displ;
      }
      centroidDispl = sqrt(centroidDispl);

      // Communicates centroid displacement
      MPI_Allreduce ( MPI_IN_PLACE, &centroidDispl, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD );

      ++iter;
   }
}
